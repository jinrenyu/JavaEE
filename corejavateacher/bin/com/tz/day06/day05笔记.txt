面向对象的基础

OO			面向对象
OOP			面向对象编程
OOAD		面向对象的分析与设计

面向对象是一种编程思想,而非一门技术
用来与面向过程加以区分.

面向过程:先考虑数据结构和算法

面向对象:先考虑对象,再考虑数据结构和算法
首先找"对象",接下来就是分析"对象",主要体现在这个对象的
"属性"(属性)和"功能"(方法),还要对这些对象进行抽象,归类,
找出它们之间的关系,最后还是数据结构和算法.

----------------------------------------------------------------

Java是一种纯面向对象的语言,面向对象的语言具有如下特点:
1.封装
2.继承
3.多态
4.抽象
5.接口
...
----------------------------------------------------------------

类和对象

什么是类(Class)?
类是一种抽象的概念,是对象的抽象
人们把一类具有共性的对象抽象出一个"类"别

什么是对象(Object)?
对象就是具体的,类的实例

类和对象的关系?
类是对象的抽象化,而对象是类的实例化
所以,JVM一定是先加载类,然后才能实例化对象
----------------------------------------------------------------

类的组成
属性和方法

语法:
package xxx.xxx.xxx;

import xxx.xxx.xxx;

public class Xxx{
	//属性定义

	//方法定义
	1.构造方法
	2.getterr/setter方法
	3.重写方法
}

---------------------------------------------------------------
属性的定义:

语法
修饰符 数据类型 属性名 [= 属性值];

注:属性也叫做成员变量(Member Variable),也叫做域(field).

局部变量:只能在定义它的{}中有效,跳出{},则变量不存在
成员变量:定义在属性位置,和该类中所有的方法是平级的,所以,该类中所有的方法均能访问到

成员变量的生命周期  > 局部变量的生命周期


修饰符		所有类    子类	  同包	 	  本身
public		YES	  YES    YES     YES
protected	NO	  YES    YES     YES
[]			NO    NO	 YES     YES
private		NO	  NO	 NO	 	 YES

注:实体类属性尽量使用private,常量使用public


构造方法(Constructor)
它也叫做构造器,作用是创建对象的时候给属性赋值

构造方法的特点:
1)构造方法的方法名必须与类名一致
2)构造方法没有返回类型
3)如果一个实体类中没有任何构造方法,则系统会自动创建一
  个空参构造供创建对象使用
4)如果一个实体类中已经提供有参数构造,则系统不会自动创
  建空参构造了

注:
如果在创建对象后,没有给属性赋值,则属性会有它所对应数据
类型的默认值
所有对象类型	null
整数类型		0
小数类型		0.0
布尔类型		false
char		'\u0000'


getters/setters方法:获取值和修改值

注意:getters/setters和构造方法都可以通过开发工具自动生成!
--------------------------------------------------------------

set方法和构造方法的异同:
相同点:
都可以给属性赋值

不同点:
a.构造方法赋值的机会只有一次,当且仅当创建对象的时候,而set方法
赋值的次数可以任意.

b.构造方法赋值相对set方法来的简便

c.set方法可以进行参数有效性判断,而构造方法不行!
      但是可以把set方法整合到构造方法中,使得构造方法也具有参数有效性判断能力

--------------------------------------------------------------

this关键字

作用一:代表当前对象

如果定义的构造方法或者普通方法中,传入的参数与属性名相同,
则可以使用this来加以区分
this.属性名 = 属性名;


作用二:在构造方法中调用当前实体类中另一个已经存在的构造方法
要求:
a.被调用的构造必须存在
b.此条语句必须放在构造方法的第一行
--------------------------------------------------------------

方法的重载(OverLoad)
定义:同一个方法在不同的环境下有不同的功能

前提条件:
一定是发生在同一个类中

要求:
1.方法名必须相同
2.返回类型可以不同
3.参数列表必须不同
  a.参数列表的个数不同
  b.参数列表的顺序不同
       类型一致,顺序不同
       类型不一致,顺序不同
  c.参数列表的类型不同
4.构造方法允许重载

如:
public class Calc{
	public int add(int a,int b){
		return a + b;
	}
	public double add(double a,double b){
		return a + b;
	}
	//以上两个方法构成方法重载
}

为什么有方法重载:
答:可以使用统一的方法名字来概括一类方法,便于记忆和使用,简化API.
---------------------------------------------------------------

JVM的内存结构

1.栈区(Stack) -- 先进后出	类似于弹夹
  大小确定,效率高,速度块,但是不能动态分配

  一般局部变量存放在栈区


2.堆区(heap) -- 先进先出
  大小不确定,可以动态分配,但是效率相对较低

  使用new关键字来申请堆空间

  堆空间一般用来存放对象本身

  如:Scanner sc = new Scanenr(System.in);
     Scanner对象存放在堆区,而引用sc存放在栈区,指向堆空间中的
     Scanner对象


3.代码区
  用来存放字节码文件,方法,静态成员.
----------------------------------------------------------------

对象和引用的关系

引用中存放的是对象的内存地址,指向具体的某一个在堆空间的对象

如:
Cup c1;//申请了一个变量c1,没有创建对象
c1 = new Cup();//此时,在堆空间中创建了一个Cup对象,并且把它的
                 内存地址赋值给存放在栈区的引用c1
Cup c2 = new Cup();//在堆空间中创建一个新杯子被c2引用
c1 = c2;//把c2的地址赋值给c1,此时c1和c2同时指向第二次创建的杯子,
        //而第一个创建的杯子没有任何引用所指向,就成了垃圾对象

注:气球理论
一个引用在某一个时刻最多只能指向一个对象
一个对象在某一个时刻可以被多个引用所指引
----------------------------------------------------------------

JVM的垃圾回收机制

它的目的就是用来自动回收"垃圾对象"(没有任何引用所指向的对象).

GC(Garbage Collection),它也是一个后台守护线程
只要JVM正在运行,GC线程一定存在

JVM一旦启动,就会启动两条线程
1.main,负责调用main方法
2.GC,负责垃圾回收

注:
GC去回收垃圾对象的时间是不确定的,它有自己的算法,
不能由程序来控制,但是可以通过以下方法来提醒

1.Runtime.getRuntime().gc()
2.System.gc()

结论:以上两个方法不能调用gc回收垃圾对象,仅仅是一种提醒和尝试,
     gc运不运行还是有它自己说了算.

如:
Cup c1 = new Cup();
...
c1 = null;//此时JVM不是一定立马执行回收程序
